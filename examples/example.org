#+OPTIONS: toc:nil
#+Title: Example for a LaTeX document
#+Author: Dario Klingenberg

* Introduction
  This document is intended to give an overview of what this library is useful for.
Since the goal I am trying to accomplish might be difficult to understand (the actual 
path to the goal is surprisingly simple),
I will start by explaining what led me to write this. 
If you write (complicated) LaTeX and like lisp, this might be useful for you, or 
at least provide some food for thought.
** Motivation
LaTeX, like all modern markup languages I am aware of, has the huge advantage over
WYSIWYG editors that it separates content from representation. 
To start a new chapter in LaTeX, it is natural to write \chapter{chapter-name},
instead of something like \textbf{chapter-name}. Even though your LaTeX style 
may end up setting chapter headings in bold, most users are aware that
it would be terrible style hard-code that into your document source. 

On the other hand, when writing math formulas, it is not uncommon to see something like
\begin{equation}
\frac{d^2 y}{dx^2} = 0.
\end{equation}
(I'll admit that I used to also be guilty of writing LaTeX like this)
What we want to represent here is the second derivative of y with respect to x - 
not a fraction with some weird expressions in the enumerator and the denominator.
It just so happens that derivatives are often written like this.
So, what we really should be doing is to create a LaTeX macro, called e.g.
\derivative, that would allow us to write
\begin{equation}
\derivative[2]{y}{x} = 0
\end{equation}
and obtain the same as above. This has at least three big advantages:
- it is easier to write (no need for snippets)
- it is easier to read
- if we decide to change the notation (e.g. to y^{\prime \prime}), we only have to change the LaTeX macro, not our LaTeX source.
I actually created a large number of such LaTeX macros to abstract my formulas - you can find them 
in my github. 
It turns out that even in this seemingly simple example, the 
macro does require some programming. For instance, if we have a first order derivative,
we do not want it to expand to
\frac{d^1 y}{dx^1}, but to omit the ones in the exponents. Also, if we mostly deal with first 
derivatives, we would like the number denoting the order of the derivative to 
be an optional argument. 
Personally, I found that even in this simple case, LaTeX is not a lot of fun 
to program in. As the macros I wanted to create became more and more complex, 
the quality of my LaTeX code quickly deteriorated. In some instances, I just copy/pasted 
code from stackoverflow. As a side effect, I often ended up not abstracting my formulas at
all.

When learing about lisp, I had the sudden realization that LaTeX code is just 
a long string that can be generated by any programming language in the world (code=data and 
all that). Of course, I wanted to use lisp to accomplish this.
After doing some research, I decided that none of the existing solutions 
quite matched what I was trying to do, I decided to implement this library.

* Low level lisp functions
- tex-cmd
- tex-env

* Writing my own parser
- tex-eval-lisp

* Possible workflows
** Write everything in lisp
** Input lisp-generated files into a main document
** Use Emacs Org-mode (recommended)
I completely rely on org-mode's export capabilites. This lisp library only 
comes into play when I have to generate (complicated) LaTeX code, especially 
longer formulas. Rather than write it ourselves or deal with LaTeX macros,
we can just use lisp (or any other language we like) to generate the LaTeX code 
for us. The question that of course remains is how to integrate that into our workflow. 
While there are probably many other ways (in particular, we could 
just generate the entire document using lisp), I find that org-mode makes it most 
simple - see the next section :)

* A section with formulas
  This section is very interesting, because it contains lisp-generated LaTeX code!
#+BEGIN_SRC lisp :exports results :results LaTeX
      (ql:quickload :clisptex)
      (in-package :clisptex)
      (tex-eval
       '(tex-multi-eq
	 (list
	  (group 
	   1 + 1 &= 2)
	  (group
	   (dd y x 2) + y &= 0))
	 (list
	  eq-simple
	  eq-differential)))
#+END_SRC
Labels are optional, but when given, we can easliy refer to equation ref:eq-differential.
